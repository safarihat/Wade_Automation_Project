{% extends 'wade_automation/base.html' %}
{% load static %}

{% block title %}Step 3: Map Inherent Vulnerabilities{% endblock %}

{% block extra_head %}
    <!-- MapLibre GL CSS -->
    <link href='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css' rel='stylesheet' />
    <!-- Mapbox GL Draw CSS (compatible with MapLibre) -->
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.css' type='text/css' />
    <style>
        #map { height: 70vh; width: 100%; border-radius: 8px; }
        .map-wrapper {
            /* The grid layout is removed to stack the map and sidebar vertically. */
        }
        .sidebar {
            padding: 1.5rem;
            background-color: #f8f9fa;
            border-radius: 8px;
            /* height is now auto, and we add a margin-top for spacing. */
            margin-top: 2rem; 
            min-height: 300px;
        }
        .map-container { position: relative; }
        .map-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-family: sans-serif;
            z-index: 1;
        }
    </style>
{% endblock %}

{% block content %}
<main class="page-section">
    <div class="container-fluid">
        <h1 class="text-center">Step 3: Map Inherent Vulnerabilities</h1>
        <p class="lead text-center">Below is a map of your property and an AI-generated technical summary of its environmental context and inherent risks. Review this overview before proceeding.</p>

        <div class="map-wrapper mt-4">
            <div style="position: relative; flex-grow: 1;">
                <div id="map"></div>
                <div id="map-overlay" class="map-overlay">
                    <input id="aerial-layer" type="radio" name="rtoggle" value="aerial" checked="checked"><label for="aerial-layer">Aerial</label>
                    <input id="topo-layer" type="radio" name="rtoggle" value="topo"><label for="topo-layer">Topo</label>
                    <hr style="margin: 4px 0;">
                    <input type="checkbox" id="lucas-toggle"><label for="lucas-toggle">Land Use (LUCAS)</label>
                </div>
            </div>

            <div class="sidebar">
                <h5>Technical Vulnerability Summary</h5>
                <!-- The loading spinner will now handle the initial message -->
                
                <div id="analysis-container" class="mt-3">
                    <div id="analysis-output" class="p-3 bg-white border rounded" style="min-height: 300px; font-size: 0.9rem; white-space: pre-wrap; position: relative;">
                        <!-- AI analysis will be loaded here -->
                        <div id="analysis-loader" class="text-center text-muted pt-5">
                            <div class="spinner-border spinner-border-sm" role="status"></div>
                            <p class="mt-2 small">Generating technical summary...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <form method="post" class="mt-3">
            {% csrf_token %}
            <input type="hidden" name="vulnerability_features" id="id_vulnerability_features">
            <div class="d-flex justify-content-end mt-4">
                <a href="{% url 'doc_generator:plan_wizard_details' pk=plan.pk %}" class="btn btn-lg btn-outline-secondary"><i class="fas fa-chevron-left me-2"></i>Back to Details</a>
                <button type="submit" class="btn btn-lg btn-gradient ms-3">Save & Continue<i class="fas fa-chevron-right ms-2"></i></button>
            </div>
        </form>
    </div>

    <!-- Data container for JS -->
    <div id="map-data"
         data-plan-pk="{{ plan.pk }}"
         data-lat="{{ plan.latitude|default:'' }}"
         data-lon="{{ plan.longitude|default:'' }}"
         data-linz-key="{{ LINZ_API_KEY|safe }}"
         data-linz-basemaps-key="{{ LINZ_BASEMAPS_API_KEY|safe }}"
         data-koordinates-key="{{ KOORDINATES_API_KEY|safe }}"
         data-existing-features="{{ vulnerability_features_json|escapejs }}"
         style="display:none;"></div>
</main>
{% endblock %}

{% block extra_js %}
<!-- MapLibre GL JS -->
<script src='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js'></script>
<!-- Mapbox GL Draw (works with MapLibre) -->
<script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.js'></script>
<!-- Turf.js for geospatial computations -->
<script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const dataEl = document.getElementById('map-data');
    const lat = parseFloat(dataEl.dataset.lat) || -41.2865; // Fallback: Wellington lat
    const lon = parseFloat(dataEl.dataset.lon) || 174.7762; // Fallback: Wellington lon
    const linzKey = dataEl.dataset.linzKey || '';
    const linzBasemapsKey = dataEl.dataset.linzBasemapsKey || '';
    const koordinatesKey = dataEl.dataset.koordinatesKey || '';
    const existingFeatures = JSON.parse(dataEl.dataset.existingFeatures || 'null');
    const hiddenInput = document.getElementById('id_vulnerability_features');
    const vulnerabilityTypes = {
        'farm_boundary': { color: '#e60049', name: 'Farm Boundary' },
        'leased_land': { color: '#9b19f5', name: 'Leased Land' },
        'land_use_zone': { color: '#0bb4ff', name: 'Land Use Zone' },
        'land_unit': { color: '#50e991', name: 'Land Unit' },
        'soil_type': { color: '#ffa300', name: 'Soil Type' },
        'surface_water_body': { color: '#00bfa0', name: 'Surface/Artificial Water' },
        'slope_landform': { color: '#e6d800', name: 'Slope/Landform' },
        'iwg_zone': { color: '#ffb3e6', name: 'Winter Grazing' },
        'critical_source_area': { color: '#7e7d7e', name: 'Critical Source Area' },
        'drainage_system': { color: '#a349a4', name: 'Drainage System' },
        'irrigation_infra': { color: '#2a7fff', name: 'Irrigation/Frost' },
        'uncategorized': { color: '#999999', name: 'Uncategorized' }
    };

    // --- Consistent Map Initialization from Step 1 ---
    const aerialTileUrl = `https://basemaps.linz.govt.nz/v1/tiles/aerial/WebMercatorQuad/{z}/{x}/{y}.png?api=${linzBasemapsKey}`;
    const topoTileUrl = `https://tiles-cdn.koordinates.com/services;key=${linzKey}/tiles/v4/layer=52343,style=auto/EPSG:3857/{z}/{x}/{y}.png`;
    // LUCAS NZ Land Use Map 2020 v005 from MfE, hosted on Koordinates. Layer ID: 117733
    const lucasTileUrl = `https://tiles-cdn.koordinates.com/services;key=${koordinatesKey}/tiles/v4/layer=117733,style=auto/EPSG:3857/{z}/{x}/{y}.png`;

    // Initialize MapLibre
    const map = new maplibregl.Map({
        container: 'map',
        style: {
            "version": 8,
            "sources": {
                "linz-aerial": {
                    "type": "raster",
                    "tiles": [ aerialTileUrl ],
                    "tileSize": 256,
                    "attribution": "© LINZ"
                },
                "linz-topo": {
                    "type": "raster",
                    "tiles": [ topoTileUrl ],
                    "tileSize": 256,
                    "attribution": "© LINZ"
                },
                "lucas-landuse": {
                    "type": "raster",
                    "tiles": [ lucasTileUrl ],
                    "tileSize": 256,
                    "attribution": "© MfE, Manaaki Whenua"
                }
            },
            "layers": [
                {
                    "id": "linz-aerial-layer",
                    "type": "raster",
                    "source": "linz-aerial" // Visible by default
                },
                {
                    "id": "linz-topo-layer",
                    "type": "raster",
                    "source": "linz-topo",
                    "layout": { "visibility": "none" } // Hidden by default
                },
                {
                    "id": "lucas-landuse-layer",
                    "type": "raster",
                    "source": "lucas-landuse",
                    "layout": { "visibility": "none" }, // Hidden by default
                    "paint": { "raster-opacity": 0.7 }
                }
            ]
        },
        center: [lon, lat],
        zoom: 14
    });

    // --- Layer switcher logic from Step 1 ---
    document.getElementById('map-overlay').addEventListener('change', (event) => {
        // Only act on the radio buttons for base layer switching by checking their name attribute.
        if (event.target.name === 'rtoggle') {
            const layerId = event.target.value;
            if (layerId === 'aerial') {
                map.setLayoutProperty('linz-aerial-layer', 'visibility', 'visible');
                map.setLayoutProperty('linz-topo-layer', 'visibility', 'none');
            } else {
                map.setLayoutProperty('linz-aerial-layer', 'visibility', 'none');
                map.setLayoutProperty('linz-topo-layer', 'visibility', 'visible');
            }
        }
    });

    // LUCAS layer toggle logic
    document.getElementById('lucas-toggle').addEventListener('change', (event) => {
        const visibility = event.target.checked ? 'visible' : 'none';
        if (map.getLayer('lucas-landuse-layer')) {
            map.setLayoutProperty('lucas-landuse-layer', 'visibility', visibility);
        }
    });

    // Drawing controls
    const draw = new MapboxDraw({
        displayControlsDefault: false,
        controls: { point: true, line_string: true, polygon: true, trash: true },
        defaultMode: 'draw_polygon',
        styles: [
            { id: 'gl-draw-polygon-fill', type: 'fill', filter: ['all', ['==', '$type', 'Polygon'], ['!=', 'mode', 'static']], paint: { 'fill-color': ['get', 'color'], 'fill-opacity': 0.4 }},
            { id: 'gl-draw-polygon-stroke-active', type: 'line', filter: ['all', ['==', '$type', 'Polygon'], ['==', 'active', 'true']], layout: { 'line-cap': 'round', 'line-join': 'round' }, paint: { 'line-color': '#fbb03b', 'line-width': 3 }},
            { id: 'gl-draw-polygon-stroke-inactive', type: 'line', filter: ['all', ['==', '$type', 'Polygon'], ['!=', 'active', 'true']], layout: { 'line-cap': 'round', 'line-join': 'round' }, paint: { 'line-color': ['get', 'color'], 'line-width': 3 }},
            { id: 'gl-draw-line-active', type: 'line', filter: ['all', ['==', '$type', 'LineString'], ['==', 'active', 'true']], layout: { 'line-cap': 'round', 'line-join': 'round' }, paint: { 'line-color': '#fbb03b', 'line-width': 3 }},
            { id: 'gl-draw-line-inactive', type: 'line', filter: ['all', ['==', '$type', 'LineString'], ['!=', 'active', 'true']], layout: { 'line-cap': 'round', 'line-join': 'round' }, paint: { 'line-color': ['get', 'color'], 'line-width': 3 }},
            { id: 'gl-draw-point-active', type: 'circle', filter: ['all', ['==', '$type', 'Point'], ['==', 'active', 'true']], paint: { 'circle-radius': 5, 'circle-color': '#fbb03b' }},
            { id: 'gl-draw-point-inactive', type: 'circle', filter: ['all', ['==', '$type', 'Point'], ['!=', 'active', 'true']], paint: { 'circle-radius': 5, 'circle-color': ['get', 'color'] }}
        ]
    });
    map.addControl(draw);

    function updateForm() {
        const data = draw.getAll();
        hiddenInput.value = data.features.length ? JSON.stringify(data) : '';
    }

    function applyDefaultPropertiesOnCreate(feature) {
        const defaultType = 'uncategorized';
        draw.setFeatureProperty(feature.id, 'vulnerability_type', defaultType);
        draw.setFeatureProperty(feature.id, 'description', feature.properties && feature.properties.description ? feature.properties.description : '');
        draw.setFeatureProperty(feature.id, 'color', vulnerabilityTypes[defaultType].color);
    }

    // --- Function to fetch and display parcel geometry (from Step 1) ---
    async function fetchAndDrawParcel(lat, lon) {
        const parcelApiUrl = `{% url 'doc_generator:api_get_parcel_geometry' %}?lat=${lat}&lon=${lon}`;
        try {
            const response = await fetch(parcelApiUrl);
            const geojsonData = await response.json();

            if (map.getSource('parcel-boundary')) {
                map.removeLayer('parcel-boundary-layer');
                map.removeSource('parcel-boundary');
            }
    
            if (geojsonData && geojsonData.features && geojsonData.features.length > 0) {
                map.addSource('parcel-boundary', { 'type': 'geojson', 'data': geojsonData });
                map.addLayer({
                    'id': 'parcel-boundary-layer',
                    'beforeId': 'gl-draw-polygon-fill', // Draw parcel under drawn features
                    'type': 'line',
                    'source': 'parcel-boundary',
                    'paint': { 'line-color': '#FF0000', 'line-width': 2.5 }
                });
            }
        } catch (error) {
            console.error("Failed to fetch parcel geometry:", error);
        }
    }

    map.on('load', async () => {
        // Fetch the parcel boundary first but don't wait for it to finish rendering
        const parcelPromise = fetchAndDrawParcel(lat, lon);

        let hasExistingFeatures = existingFeatures && existingFeatures.features && existingFeatures.features.length > 0;

        // If there are existing drawn features, load them into the draw control
        if (hasExistingFeatures) {
            for (const f of existingFeatures.features) {
                const t = (f.properties && f.properties.vulnerability_type) || 'uncategorized';
                const color = (vulnerabilityTypes[t] || vulnerabilityTypes['uncategorized']).color;
                if (!f.properties) f.properties = {};
                f.properties.color = color;
            }
            draw.set(existingFeatures);
        }

        // Now, decide how to set the initial map view
        if (hasExistingFeatures) {
            const bbox = turf.bbox(existingFeatures);
            map.fitBounds(bbox, { padding: 50, duration: 0 });
        } else {
            await parcelPromise; // Wait for the parcel to be fetched
            const parcelSource = map.getSource('parcel-boundary');
            if (parcelSource) {
                const parcelData = parcelSource._data;
                if (parcelData && parcelData.features && parcelData.features.length > 0) {
                    const bbox = turf.bbox(parcelData);
                    map.fitBounds(bbox, { padding: 50, duration: 0 });
                }
            }
        }

        updateForm();
    });

    map.on('draw.create', (e) => {
        applyDefaultPropertiesOnCreate(e.features[0]);
        updateForm();
    });
    map.on('draw.delete', updateForm);
    map.on('draw.update', updateForm);

    // --- Automatic Vulnerability Analysis ---
    async function generateVulnerabilityAnalysis() {
        const planPk = dataEl.dataset.planPk;
        const analysisUrl = `/doc-generator/api/vulnerability-analysis/${planPk}/`;
        const outputEl = document.getElementById('analysis-output');
        const loaderEl = document.getElementById('analysis-loader');

        try {
            const response = await fetch(analysisUrl);
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: `Network response was not ok: ${response.statusText}` }));
                throw new Error(errorData.error || `Network response was not ok: ${response.statusText}`);
            }
            const data = await response.json();
            
            loaderEl.style.display = 'none'; // Hide loader
            outputEl.textContent = data.analysis_text || 'No analysis was returned.';

        } catch (error) {
            console.error('Failed to fetch vulnerability analysis:', error);
            loaderEl.style.display = 'none'; // Hide loader
            outputEl.innerHTML = `<p class="text-danger"><strong>Could not load analysis.</strong><br>Please check your API key configurations and network connection, then refresh the page.<br><br><em>Error: ${error.message}</em></p>`;
        }
    }

    generateVulnerabilityAnalysis(); // Trigger analysis on page load.
});
</script>
{% endblock %}
